# fourier bases in all directions periodic bcs
# want to turn this into vector form

import dedalus.public as d3
import numpy as np

total_time = 1.0
dt = 0.001
Re = 1000.0

Lx = 2*np.pi
Ly = 2*np.pi
Lz = 2*np.pi
Nx = 32
Ny = 32
Nz = 32

xcoord = d3.Coordinate('x') 
ycoord = d3.Coordinate('y')
zcoord = d3.Coordinate('z')
dist = d3.Distributor((xcoord, ycoord, zcoord), dtype=np.float64)
xbasis = d3.Fourier(xcoord, size=Nx, bounds=(0, Lx), dealias=3/2, dtype=np.float64)
ybasis = d3.Fourier(ycoord, size=Ny, bounds=(0, Ly), dealias=3/2, dtype=np.float64)
zbasis = d3.Fourier(zcoord, size=Nz, bounds=(0, Lz), dealias=3/2, dtype=np.float64) #d3.Fourier enforces periodc bcs 

u = dist.Field(name='u', bases=(xbasis, ybasis, zbasis))
v = dist.Field(name='v', bases=(xbasis, ybasis, zbasis))
w = dist.Field(name='w', bases=(xbasis, ybasis, zbasis))
p = dist.Field(name='p', bases=(xbasis, ybasis, zbasis))

dx = lambda A: d3.Differentiate(A, xcoord)
dy = lambda A: d3.Differentiate(A, ycoord)
dz = lambda A: d3.Differentiate(A, zcoord)
div = lambda A, B, C: dx(A) + dy(B) + dz(C)
lap = lambda A: dx(dx(A)) + dy(dy(A)) + dz(dz(A))
grad = lambda A: (dx(A), dy(A), dz(A))

tau_p = dist.Field(name='tau_p', bases=None)

problem = d3.IVP([u, v, w, p, tau_p], namespace={"Re":Re, "dx":dx, "dy":dy, "dz":dz, "div":div, "lap":lap, 'Lz':Lz})

problem.add_equation("dt(u) - (1/Re)*lap(u) + dx(p) = -u*dx(u) - v*dy(u) - w*dz(u)")
problem.add_equation("dt(v) - (1/Re)*lap(v) + dy(p) = -u*dx(v) - v*dy(v) - w*dz(v)")
problem.add_equation("dt(w) - (1/Re)*lap(w) + dz(p) = -u*dx(w) - v*dy(w) - w*dz(w)")
problem.add_equation("div(u, v, w) + tau_p = 0")
problem.add_equation("integ(p) = 0")

U0 = 1
u['g'][:] = U0
v['g'][:] = 0
w['g'][:] = 0
p['g'][:] = 0

# Add small random perturbations to the velocity fields
np.random.seed(42)
epsilon = 0.01 * U0 
u['g'] += epsilon * np.random.randn(*u['g'].shape)
v['g'] += epsilon * np.random.randn(*v['g'].shape)
w['g'] += epsilon * np.random.randn(*w['g'].shape)

solver = problem.build_solver(d3.RK443)
solver.stop_sim_time = total_time

while solver.proceed:
    solver.step(dt)
    t = solver.sim_time
    if solver.iteration % 100 == 0:
        print(f"Iteration: {solver.iteration}, Time: {t:.3f}")


